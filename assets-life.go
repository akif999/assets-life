// Copyright (C) 2019 Ichinose Shogo All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in https://github.com/shogo82148/assets-life/blob/master/LICENSE

// assets-life is a very simple embedding asset generator.
// It generates an embed small in-memory file system that is served from an http.FileSystem.
// Install the command line tool first.
//
//     go get github.com/shogo82148/assets-life
//
// The assets-life command generates a package that have embed small in-memory file system.
//
//     assets-life /path/to/your/project/public public
//
// You can access the file system by accessing a public variable Root of the generated package.
//
//     import (
//         "net/http"
//         "./public" // TODO: Replace with the absolute import path
//     )
//
//     func main() {
//         http.Handle("/", http.FileServer(public.Root))
//         http.ListenAndServe(":8080", nil)
//     }
//
// Visit http://localhost:8080/path/to/file to see your file.
//
// The assets-life command also embed go:generate directive into generated code, and assets-life itself.
// It allows you to re-generate the package using go generate.
//
//     go generate ./public
//
// The assets-life command is no longer needed because it is embedded into the generated package.
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	pkgpath "path"
	"path/filepath"
	"strings"
)

func main() {
	if len(os.Args) <= 2 {
		log.Println("Usage:")
		log.Println(os.Args[0] + " INPUT_DIR OUTPUT_DIR [PACKAGE_NAME]")
		os.Exit(2)
	}
	in, err := filepath.Abs(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	out, err := filepath.Abs(os.Args[2])
	if err != nil {
		log.Fatal(err)
	}
	var name string
	if len(os.Args) > 3 {
		name = os.Args[3]
	}
	if name == "" {
		name = filepath.Base(out)
	}
	if err := build(in, out, name); err != nil {
		log.Fatal(err)
	}
}

func build(in, out, name string) error {
	filename := "assets-life.go"
	rel, err := filepath.Rel(out, in)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(out, 0755); err != nil {
		return err
	}
	f, err := os.OpenFile(filepath.Join(out, "filesystem.go"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	header := `// Code generated by go run %s. DO NOT EDIT.

//%s

package %s

import (
	"io"
	"net/http"
	"os"
	"path"
	"sort"
	"strings"
	"time"
)

// Root is the root of the file system.
var Root http.FileSystem = fileSystem{
`
	fmt.Fprintf(f, header, filename, "go:generate go run "+filename+" \""+rel+"\" . "+name, name)
	err = filepath.Walk(in, func(path string, info os.FileInfo, err error) error {
		// ignore hidden files
		if strings.HasPrefix(info.Name(), ".") {
			return nil
		}

		fmt.Fprintf(f, "\tfile{\n")
		if info.IsDir() {
			fmt.Fprintln(f, "\t\tcontent: \"\",")
		} else {
			b, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}
			fmt.Fprintf(f, "\t\tcontent: %q,\n", string(b))
		}
		rel, err := filepath.Rel(in, path)
		if err != nil {
			return err
		}
		fmt.Fprintf(f, "\t\tname:    %q,\n", pkgpath.Clean("/"+filepath.ToSlash(rel)))
		mode := info.Mode()
		switch {
		case (mode&os.ModeType)|os.ModeDir != os.ModeDir:
			return fmt.Errorf("unsupported file type: %s", mode)
		case mode.IsDir(): // directory
			fmt.Fprintln(f, "\t\tmode:    0755 | os.ModeDir,")
		case mode&0100 != 0: // executable file
			fmt.Fprintln(f, "\t\tmode:    0755,")
		default:
			fmt.Fprintln(f, "\t\tmode:    0644,")
		}
		fmt.Fprint(f, "\t},\n")
		return nil
	})
	if err != nil {
		return err
	}
	footer := `}

type fileSystem []file

func (fs fileSystem) Open(name string) (http.File, error) {
	i := sort.Search(len(fs), func(i int) bool { return fs[i].name >= name })
	if i >= len(fs) || fs[i].name != name {
		return nil, &os.PathError{
			Op:   "open",
			Path: name,
			Err:  os.ErrNotExist,
		}
	}
	f := &fs[i]
	return &httpFile{
		Reader: strings.NewReader(f.content),
		file:   f,
		fs:     fs,
		idx:    i,
		dirIdx: i + 1,
	}, nil
}

type file struct {
	name    string
	content string
	mode    os.FileMode
}

var _ os.FileInfo = (*file)(nil)

func (f *file) Name() string {
	return path.Base(f.name)
}

func (f *file) Size() int64 {
	return int64(len(f.content))
}

func (f *file) Mode() os.FileMode {
	return f.mode
}

var zeroTime time.Time

func (f *file) ModTime() time.Time {
	return zeroTime
}

func (f *file) IsDir() bool {
	return f.Mode().IsDir()
}

func (f *file) Sys() interface{} {
	return nil
}

type httpFile struct {
	*strings.Reader
	file   *file
	fs     fileSystem
	idx    int
	dirIdx int
}

var _ http.File = (*httpFile)(nil)

func (f *httpFile) Stat() (os.FileInfo, error) {
	return f.file, nil
}

func (f *httpFile) Readdir(count int) ([]os.FileInfo, error) {
	ret := []os.FileInfo{}
	if !f.file.IsDir() {
		return ret, nil
	}

	prefix := f.file.name
	if !strings.HasSuffix(prefix, "/") {
		prefix += "/"
	}
	if count <= 0 {
		for f.dirIdx < len(f.fs) {
			entry := &f.fs[f.dirIdx]
			f.dirIdx++
			name := entry.name
			if !strings.HasPrefix(name, prefix) {
				break
			}
			if idx := strings.IndexRune(name[len(prefix):], '/'); idx >= 0 {
				continue
			}
			ret = append(ret, entry)
		}
		return ret, nil
	}

	ret = make([]os.FileInfo, 0, count)
	for f.dirIdx < len(f.fs) {
		entry := &f.fs[f.dirIdx]
		f.dirIdx++
		name := entry.name
		if !strings.HasPrefix(name, prefix) {
			return ret, io.EOF
		}
		if idx := strings.IndexRune(name[len(prefix):], '/'); idx >= 0 {
			continue
		}
		ret = append(ret, entry)
		if len(ret) == count {
			return ret, nil
		}
	}
	return ret, io.EOF
}

func (f *httpFile) Close() error {
	return nil
}`
	fmt.Fprintln(f, footer)
	if err := f.Close(); err != nil {
		return err
	}

	f, err = os.OpenFile(filepath.Join(out, filename), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	format := `// Copyright (C) 2019 Ichinose Shogo All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in https://github.com/shogo82148/assets-life/blob/master/LICENSE

// +build ignore

// assets-life is a very simple embedding asset generator.
// It generates an embed small in-memory file system that is served from an http.FileSystem.
// Install the command line tool first.
//
//     go get github.com/shogo82148/assets-life
//
// The assets-life command generates a package that have embed small in-memory file system.
//
//     assets-life /path/to/your/project/public public
//
// You can access the file system by accessing a public variable Root of the generated package.
//
//     import (
//         "net/http"
//         "./public" // TODO: Replace with the absolute import path
//     )
//
//     func main() {
//         http.Handle("/", http.FileServer(public.Root))
//         http.ListenAndServe(":8080", nil)
//     }
//
// Visit http://localhost:8080/path/to/file to see your file.
//
// The assets-life command also embed go:generate directive into generated code, and assets-life itself.
// It allows you to re-generate the package using go generate.
//
//     go generate ./public
//
// The assets-life command is no longer needed because it is embedded into the generated package.
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	pkgpath "path"
	"path/filepath"
	"strings"
)

func main() {
	if len(os.Args) <= 2 {
		log.Println("Usage:")
		log.Println(os.Args[0] + " INPUT_DIR OUTPUT_DIR [PACKAGE_NAME]")
		os.Exit(2)
	}
	in, err := filepath.Abs(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	out, err := filepath.Abs(os.Args[2])
	if err != nil {
		log.Fatal(err)
	}
	var name string
	if len(os.Args) > 3 {
		name = os.Args[3]
	}
	if name == "" {
		name = filepath.Base(out)
	}
	if err := build(in, out, name); err != nil {
		log.Fatal(err)
	}
}

func build(in, out, name string) error {
	filename := "assets-life.go"
	rel, err := filepath.Rel(out, in)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(out, 0755); err != nil {
		return err
	}
	f, err := os.OpenFile(filepath.Join(out, "filesystem.go"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	header := %c%s%c
	fmt.Fprintf(f, header, filename, "go:generate go run "+filename+" \""+rel+"\" . "+name, name)
	err = filepath.Walk(in, func(path string, info os.FileInfo, err error) error {
		// ignore hidden files
		if strings.HasPrefix(info.Name(), ".") {
			return nil
		}

		fmt.Fprintf(f, "\tfile{\n")
		if info.IsDir() {
			fmt.Fprintln(f, "\t\tcontent: \"\",")
		} else {
			b, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}
			fmt.Fprintf(f, "\t\tcontent: %%q,\n", string(b))
		}
		rel, err := filepath.Rel(in, path)
		if err != nil {
			return err
		}
		fmt.Fprintf(f, "\t\tname:    %%q,\n", pkgpath.Clean("/"+filepath.ToSlash(rel)))
		mode := info.Mode()
		switch {
		case (mode&os.ModeType)|os.ModeDir != os.ModeDir:
			return fmt.Errorf("unsupported file type: %%s", mode)
		case mode.IsDir(): // directory
			fmt.Fprintln(f, "\t\tmode:    0755 | os.ModeDir,")
		case mode&0100 != 0: // executable file
			fmt.Fprintln(f, "\t\tmode:    0755,")
		default:
			fmt.Fprintln(f, "\t\tmode:    0644,")
		}
		fmt.Fprint(f, "\t},\n")
		return nil
	})
	if err != nil {
		return err
	}
	footer := %c%s%c
	fmt.Fprintln(f, footer)
	if err := f.Close(); err != nil {
		return err
	}

	f, err = os.OpenFile(filepath.Join(out, filename), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	format := %c%s%c
	fmt.Fprintf(f, format, 96, header, 96, 96, footer, 96, 96, format, 96)
	if err := f.Close(); err != nil {
		return err
	}
	return nil
}
`
	fmt.Fprintf(f, format, 96, header, 96, 96, footer, 96, 96, format, 96)
	if err := f.Close(); err != nil {
		return err
	}
	return nil
}
